[HIDmon-14K50](HIDmon-14K50.md) 


ReadMe.txtより抜粋
- - - -
	 -------------------------------------------------------------------
	             PIC 18F14K50  用 HID bootloader / HIDmon
	 -------------------------------------------------------------------

■ 概要

	  これはdiolanが提供しているPIC 18F4455用のHIDブートローダーを元にして
	  作成した HID bootloader 兼 HID monitorです。

■ 何に使うのですか？

	  MicroChipが提供しているFirmware-Bと呼ばれるブートローダーの代替に使えます。

	  ブートローダーとは：

	  18F2550/4550/14K50 シリーズのPICは、USBでパソコンと簡単に接続できるので、
	  最初にブートローダーを焼いておくことによって、毎回PICライターを使用
	  することなく、USB経由でプログラムを転送、実行出来、手軽にPICプログラム
	  の開発が出来ます。

	  それだけではなく、AVRでお馴染みの HIDmon の機能も併せ持っています。

■ 用意するハードウェアは？

	    PIC 18F14K50   ( 秋月電子通商にて １個 200円 で販売されています )

	    制作する場合の必要最小限の外付け部品は、
	(1)  RC0,RC1 にLEDを接続。 LED は電流制限抵抗1kΩ程度を直列に繋いで、片側(-)はGND接続とします.
	(2)  RC2 は10kΩ程度でPULL-UPして、手動の押しボタンスイッチを押している間だけ GNDに接地する
	     ように配線します。
	(3)  RESETスイッチをMCLR端子とGND間に用意します。

	その他必要な配線.
	 水晶 12MHz  
	 水晶用の負荷コンデンサ２個(15pF程度? 無くてもとりあえず発振はします) 
	    USBコネクタ(D+ D-) 
	    他電源まわりの配線、
	 パスコン（5V-GND間は0.1uF積層セラミック+10uF電解,Uvsb-GND間は0.1uF積層）
	    などが必要となります。


■ ブートローダーとして使えますか？

	  ●一応使えます。

	  ・外部のPICライターを用意して、hexfiles/bootloader-0000.hex を焼きます。
	  ・USB側に繋ぐと、RC0に接続されたLEDが点滅を始めればOKです。

	   host/picmon.exe   : HIDmon の PICバージョンです。
	   host/picboot.exe  : ブートローダーです。 HEXファイルを書き込みできます。
	   が動作することを確認します。

	  ●基本的な使い方.

	  C:> picboot myfile.hex
	  myfile.hex をFlashに書き込みます。

	  C:> picboot -r
	  Flashに書き込まれている0x800番地から実行可能なプログラムを起動します。

	  C:> picboot -r myfile.hex
	  myfile.hex をFlashに書き込んで、実行します。（上記の２つの動作を一度に行います）

	  C:> picboot -rp a.hex
	  現在書き込まれているFlashの内容を HEXFILE形式で 'a.hex' に出力します。

	  C:> picboot -E
	  Flashの内容を全消去します。(通常の書き込みでは、書き込みに必要な部分のみ消去します)

	  ● オプションの説明

	  ・'-s'オプションについて.
	      picboot -s1000 USBDevice-CDC-BasicDemo-C18-LowPinCountUSBDevelopmentKit.hex
	    '-s' に続けて１６進数で開始アドレスを指定すると、0x800番地スタートでないアプリケーション
	  についてもブート可能な形で書き込み出来ます。(0x800番地にjmpテーブルが書き込まれます)

	  ・'-B'オプションについて.
	    '-B' オプションはブートプログラム領域に対する読み書きを許可するオプションです。
　　これをうまく使うことで、0x800番地に書かれたブートローダーから、0x0000番地のブートローダー
　　の更新を行うことが出来ます。

■ picbootの使い方に関する注意

	  ・ブートローダーとして機能させる場合はRC2端子に接続されたスイッチを押してRC2=Lowレベル
	    にした状態から通電、あるいはリセットを行ってください。

	  ・そうでない場合は0x800番地のアプリケーションが起動するようになっています。

	  ・アプリケーションが書き込まれていない状態（最初にブートローダーを書き込んだ直後）では
	    RC2端子状態にかかわらずブートローダーが起動するようになっています。
	    (0x800番地に、ブートローダーに戻るjumpコードが書き込まれています)



■ テスト版(0x0800オリジン)の使い方を教えてください。

	  ・このブートローダーを使って、新しいバージョンもしくは新機能を追加したローダー
	    を開発する場合に使用します。



■ 再ビルドの方法は？

	  ・MicroChipの MPLab(MPASMWIN) をインストールして、MPASMWIN.EXEの実行パスを
	  　通しておいてください。

	  ・make を実行します。 make.exe はWinAVRなどで使用している一般的なGNU make 
	    が使えます。

	  ・GNUPICツールの gpasm を使用することも検討しましたが、gpasmの致命的なバグ
	    により、どうあがいても正しいHIDディスクリプタが生成出来ないようですので
	    お勧めはいたしません。
	    ( gpasm のバグが修正されれば再検討します )


	  ● ホスト側ツールは MinGW gcc を使ってビルドしてください。

	     -mno-cygwin オプションを付けることで、 Cywin gcc でもコンパイルできる
	     はずですが、テストはしていません。


■ オリジナル版bootloaderからの変更点

	  ・ PIC18F14K50 に対応しました。
	  ・ 他のブートローダーから起動できるようにオリジンを変えられるようにしました。
	  ・ 暗号処理は容量の都合で削除しました。
	  ・ XINST (PIC18F2550などで追加された拡張命令) を使用しないようにしています。
	     具体的には addfsr と subfsr 命令です。
	  ・ HID Reportの転送方法を全て Control 転送で行うように変更しています。


■ 注意事項

	  ・ このブートローダーは XINST=ON / OFF のどちらでも動作しますが、ブートローダー
	     から起動するプログラムは、その書き方によりどちらかを仮定していることが殆ど
	     です。
	  ・ 特に、sdccでコンパイルされたプログラムはXINST=OFFでないと動作しません。
	           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  ・ 焼く場合に XINST のモードをよく確認してください。
	     変更する場合は、 fuse.h の XINST= の項目を編集して再ビルドしてください。
	  ・ 添付しているhexfiles は XINST=OFF で作成しました。

■ 他に使い道はないのですか？

　 ● 以下のような用途を考えています。

　 ・PIC 18F2550 を使用した、最小構成のHID-USBフレームワークとして。

	    HIDではデバイスドライバーを書いたり、インストールする必要がありません。
	    Win32APIを使用して、HIDコントロール転送を自由に使用できます。

■ 問題点

　 ・現状のソースの書き方がフルアセンブラ風味なので、Ｃ言語と比べてメンテナンス性に
　　 問題があります。

　 ・たとえば、BSR(バンクセレクトレジスタ)がデフォルト値(現在は4)である前提で
　　 コーディングされているので、Ｃ言語から呼ぶエントリーを設けるとすると
　　 それらの先頭にmovlb 4 を付加する必要があります。
	    --> 2009-0507: biosコールのエントリーに付いては対策済みです.

　 ・FSR を使いまくっているため、同レジスタをスタックポインタとして使うsdccと競合します。

	    --> 2009-0506: FSR1 を使わないよう改造しました。
	    --> 2009-0507: FSR2 も保存する必要性を発見しました。FSR2はスタックフレームレジスタ
	        になっていて、上位が 0x01 固定です。 (FSR1も同じ)
	        sdccではスタックエリアは 0x100 〜 0x1ff となっているようです。（まるでmcs6502! ）
	        現状では FSR2 が破壊される問題が残ったままです。

　 ・AccessAreaのRAM(0番地〜0x5f番地)の使用に関してもＣとasmで競合が発生します。
	    --> 2009-0507: 0x0000 〜 0x01ff を全く使わないように bootloaderを書き換えました。


■ どうしてＣ言語を使わないのですか？

　 ・diolan社に聞いてください。

　 ・Ｃ言語で2kBに収まるHID bootloaderを書くのは至難の業なのかもしれません。
	    MicroChipのHID bootloaderは4kBもあります。

　 ・試しにＣ言語でコーディングしてみるとすぐ分かります。

	    asm リストを見ると笑っちゃうようなコードが吐かれていますが、誰にもどうする
	    こともできません。 
	    たぶん gcc を移植しても PIC18Fのアーキテクチャーの前には全てが徒労に終わるでしょう。

	    唯一の解決策は、全部手でコーディングすることです。TK-80の時代に戻りましょう。


■ ライセンスは？

	  ・GPL (GNU Public License v3)だそうです。

■ PIC BIOS 内蔵です。

	   bootloader のエリア 0x000c 〜 0x0018 にJump Table を設けて、BIOSの一部機能
	   をアプリケーションから呼び出せるようにしています。
	   
	   サンプルソースは hidmon/test/ 以下にあります。
	   テストする場合は、g.bat を起動してください。
	   
	   機能としては、
	・１文字 bios_putc(char c)
	   ・文字列 bios_puts(char *s) 
	・bootloaderに戻る bios_exit()
	があります。
	
	サンプルでは
	Hello World を16回表示したのち、bootloader に制御を戻すようになっています。
	
	Hello World の表示中(sdccで書かれたアプリ動作中)でもESCか^Cキーを押すとモニタ
	の機能が使えるようになっています。
	
	print 表示機能に戻す場合は 引数なしの "run" コマンドを実行してください。
	


	  ・BIOSエントリー(仮)
;-----------------------------------------------------------------------------
;	0x000c 〜 0x0018:	6 Entries.
	bra		bootloader_loop	; ブートローダー側のメインループ処理.
	bra		bios_task  ; main_loop のようなところで毎回呼ぶ。USBステートマシン.
	bra		bios_puts  ; 未実装.  test/bios.c 内に代用実装済み.
	bra		bios_getc  ; １文字を入力. 戻り値は WREG . キー入力が空なら 0を返す.
	bra		bios_putc  ; １文字を表示. 引数仕様は WREG = ascii コード.
	bra		bios_setmode ; 文字列取得モードの変更.WREG = mode (0xc0がデフォルト)
	                        ; アプリを terminateしたいときは先に mode = 0xc9 を与える.
						 ; そうするとhost側(picmon.exe)が "* Terminate"文字列を出す.
;-----------------------------------------------------------------------------


■ オプションの切り替え方法

（１）    Makefile:
	   VECTOR=0000
	   #VECTOR=0800
	   #VECTOR=1000

	   上記 VECTOR = の定義 を差し替えれば、0番地オリジン,800番地オリジンの切り替えが
	   可能です。書き換えた後、make cleanしてから makeしてください。

	   VECTOR=0800 を選んだ場合は0x800番地オリジンになり、他のブートローダーもしくは
	   このブートローダーを使用してデバッグできます。




[AVR_Monit](AVR_Monit.md)  ＜−ダウンロードはこちらのページにあります。



- - - -
## ＡＶＲ＿Ｍｏｎｉｔの使い方
- - - -

（１）ATtiny2313 を用意します。

（２）src/main.hex を焼きます。

（３）[ＡＶＲＵＳＢ](http://www.obdev.at/products/avrusb/index.html) 
にある[回路図](http://www.obdev.at/Images/avrusb/circuit.gif) 
通りに配線します。

（４）ＰＣに接続するとデバイスドライバーを要求しますので、
win32/windows-driver  にあるinfファイルを指定してインストールします。

（５）win32/monit.exe を起動します。~
とりあえず以下のように操作してみます。
	AVR> d
	000000 00 00 43 01 00 00 01 00
	000008 01 00 34 19 00 00 1f 11
	000010 00 80 10 00 04 00 10 00
	000018 63 00 65 00 8c 00 1f 00
	000020 63 00 00 06 00 00 00 00
	000028 30 00 00 20 00 00 00 00
	000030 09 73 01 00 00 00 01 f0
	000038 01 00 00 03 00 ff 7f 00
	AVR> q

- - - -
## ＡＶＲ＿Ｍｏｎｉｔに出来ること
- （１）ＡＶＲ側の任意のポート、メモリーの内容を参照する。
- （２）ＡＶＲ側の任意のポート、メモリーの内容を書き換える。（ＰＧＭＥＭは不可）
    - monit.exeを使用してインタラクティブに行う方法と、
    - 自作コマンドラインツールを作成してＰＣ上のプログラムにやらせる方法
    - の２種類がある。

<!-- dummy comment line for breaking list -->
~
- （３）ＵＳＢバルク転送、あるいはコントロール転送のベンチマークを実行出来る。
- （４）ＡＴｔｉｎｙ２３１３のポート名を覚える学習に使用できる。
    - というかこれが私的用途だったりする。

<!-- dummy comment line for breaking list -->

## ＡＶＲ＿Ｍｏｎｉｔに出来ないこと
- （１）リアルタイムに近い間隔でポートを参照したり変更したりすることは出来ない。
    - ＰＣから行うので、最小間隔は１ｍＳ。ホストＰＣのＵＳＢコントローラ次第でその１/４程度のサンプリングしか出来ない。--自作コマンドラインツールの場合。
    - ＡＶＲ＿Ｍｏｎｉｔのコマンドライン入力で行う場合は、人間のキー操作反応速度より速く出来ない。
- （２）割り込み処理が出来ない。
    - 割り込み処理を組み入れたい場合は自力でファームウェアと対応コマンドを拡張するしかない。
    - ＵＳＢのデータ転送中は割り込み禁止になるので、１パケットの転送完了時間より短いような割り込みをさばくことはＡＶＲＵＳＢにとって原理的に無理がある。
    - （そういう場合だけＵＳＢを止めればよいという意見もあるが、１２８バイトしかないＲＡＭ（空き容量はたかが４０バイト程度）のどこにデータを貯めるのだ。）

<!-- dummy comment line for breaking list -->



- - - -
## ＡＶＲ＿Ｍｏｎｉｔの使い道について

- 最小限のＡＶＲ to ＵＳＢ接続ハードウェア環境において、ＡＶＲチップのコントロールをＰＣから行うことが出来る。

<!-- dummy comment line for breaking list -->

- ＰＣのコマンドラインツールを拡張することで各種リモートセンサー、ロガー、スイッチ、等のプロトタイピングを迅速に行うことが出来る。

<!-- dummy comment line for breaking list -->

- ＡＶＲファームウェア側の空き容量を大きく取るように考慮しているので、ファームを拡張してコマンドを追加することが出来る。
    - コントロール転送版ファームウェアサイズ
    
    		ROM: 1558 bytes (data=2)
    		RAM: 53 bytes
    - バルク転送版ファームウェアサイズ
    
    		ROM: 1836 bytes (data=4)
    		RAM: 67 bytes

<!-- dummy comment line for breaking list -->
- - - -
## ＡＶＲ＿Ｍｏｎｉｔのポリシーみたいなものをあえて列挙する
- 出来る限り安く。敷居を低く。手軽に。
- ＡＶＲやマイコン学習の素材として。
    - 実は自分が私的自己学習をやっているだけかも・・・。
- 拡張して使うための元になるフレームワークとして。
- ＵＳＢということは、必ずＰＣと接続されるので、基本動作のコマンドだけ用意しておいて、残りはＰＣ側のコマンドラインツールで制御したほうがメモリー的に節約できるのではないかという考え方を採用。
- それでも、いろいろ拡張したいのでメモリーの空きを確保したい。

<!-- dummy comment line for breaking list -->

- - - -
## コントロール転送版の使い方。
ＷｉｎｄｏｗｓＶｉｓｔａで使用する場合、現状ではＬｏｗＳｐｅｅｄバルク転送が使えませんのでコントロール転送版を使用してください。
- バルク転送版とのインストール方法の違いを説明します。

<!-- dummy comment line for breaking list -->

（２）src/main.hex を焼きます −−−−＞ 代わりに　ctl/main.hex　を焼いてください。

（５）win32/monit.exe を起動します。−−−−＞ 起動オプション '-c' を入れてください。

Ｗｉｎｄｏｗｓのドライバーは共通です。
- ＰＣのＵＳＢホストにもよりますが、コントロール転送はバルク転送に比べて遅いです。（帯域制限を掛けられているような感じでバルクの半分以下しか出ません。）
- ＳｉＳのＵＳＢホストコントローラを使用する場合は、どちらも理論上の帯域速度((といっても８バイト送信の場合、わずか８ｋＢ／秒、３２バイト送信（実際は８バイトパケットが４回送信）でその４倍程度が上限))近くまで出るようです。
- バルク転送に比べて遅いですが、ファームウェアサイズを節約できるメリットがありますので、ファームを拡張して使う場合は便利です。

		ＰＧＭＥＭの空きエリア＝４９０バイト
		ＳＲＡＭは使用量５３バイトなのでスタックを加えても
		あと５０バイトくらい空いている計算。
		ＥＥＰＲＯＭは丸空き（バルクも同様）


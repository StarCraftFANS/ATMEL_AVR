[2007-09](2007-09.md) 

- - - -
#### もう１０月

- この暑さはなんなんだろう。

<!-- dummy comment line for breaking list -->

- **ＢＢＲ-４ＭＧ**を買った。

<!-- dummy comment line for breaking list -->

- しかも新品でだ。正気の沙汰ではないなぁ。暑さのせいか？

<!-- dummy comment line for breaking list -->

さて、このルーターでＷＬＡＮ　ＡＰを作ろうと思うが、はたして気力が続くだろうか？

- 中古のＡＰを買っといたほうが良かったかなぁ・・・とすでに後悔先に立たず。

<!-- dummy comment line for breaking list -->

- だめだめだぜ。すでに**ＡＶＲとは何の関係もない展開。**

<!-- dummy comment line for breaking list -->

- - - -
#### ＵＳＢ　３.０
ＭｙＣＯＭジャーナル連載記事
- [http://journal.mycom.co.jp/articles/2007/09/27/idf01/002.html](http://journal.mycom.co.jp/articles/2007/09/27/idf01/002.html) 

<!-- dummy comment line for breaking list -->

引用
	＞USB 3.0の信号にはPCI Express Gen2のx1 Laneの物理層(Electrical層とLink層)を
	＞そのまま流用した。ただし流用したのはここまでで、Transaction層は全く独自となる。 
	
	＞ソフトウェア面では、USB 2.0までのソフトウェアスタックをそのままUSB 3.0でも
	＞「なるべく」採用する。これにより、USB 2.0→USB 3.0への移行に要する手間をなるべく抑える。

ふーん。

ますますＡＶＲとは無縁の方向だな。

LowSpeed , FullSpeed , HighSpeed と来て、**次は何と呼ぶのか**だけが興味の的だ。

いやいや、もしかしたらマイクロフレームの次にナノフレームが出来るかもしれないし、
超ハイスピードハブをＡＶＲとＰＣの間に挟むことでＰＣから見たらＡＶＲ側が超ハイスピードデバイスに見えるのかもしれないという予測が当たったら笑えるというただそれだけだ。

- - - -
#### ＢＢＲ-４ＭＧは、一瞬でＬｉｎｕｘＢｏｘになった。
びんずめ堂　BBR-4MG::Linux化ファームウェア
- [http://www.binzume.net/library/bbr-4mg06.html](http://www.binzume.net/library/bbr-4mg06.html) 

<!-- dummy comment line for breaking list -->

- びんずめ堂さんのＬｉｎｕｘ化ファームのおかげで、半田ごても改造も一切なしで（そうだ、蓋さえも開けることなく((嘘。ＦｌａｓｈＲＯＭのメーカーを調べるためと、ＣＰＵの発熱具合を知るために一回フタ開けた))　）、

<!-- dummy comment line for breaking list -->
新品のＢＢＲ-４ＭＧはものの３分もしないでＬｉｎｕｘ　Ｂｏｘになってしまった。

**凄すぎる。**

- ２ＭのＦｌａｓｈによくこれだけ詰め込めますな。

<!-- dummy comment line for breaking list -->

BBR-4MGを改造してlinuxルータにする計画
- [http://www.fenix.ne.jp/~thomas/memo/bbr4/](http://www.fenix.ne.jp/~thomas/memo/bbr4/) 

<!-- dummy comment line for breaking list -->

- こちらのほうは、ＵＳＢを繋ぐために基板を改造して４８ＭＨｚの水晶モジュールを接続して、ＵＳＢメモリー

<!-- dummy comment line for breaking list -->
にファイルシステムを置くタイプ。（ファームはＵ-ＢＯＯＴだけを入れている）

- ＢＢＲ-４ＨＧのほうは２０００円くらい高いが、おそらく付属品（ＬＡＮケーブル）とファームが違うだけなんじゃなかろうか。
- ＦＬＡＳＨはｉｎｔｅｌだった。
- ＡＤＭ５１２０Ｐはｉｎｆｉｎｅｏｎ製のようだ。（ＡＤＭｔｅｃｈと違うの？）
    - （ADMtechはinfineonに買収されたらしい）
- さすがに１７５ＭＨｚなので熱くなる。
- ５．５Ｖ９００ｍＡの電源は重い。トランスのようだ。５Ｗ程度？買ってきた箱には定格３．５５Ｗと書いてある。

<!-- dummy comment line for breaking list -->

- - - -
#### ＡＶＲｔｅｒｍは１９２００に追いついてない。
- 久しぶりにH8/3048FをUSBに繋ぐ。（１９２００）
- ＶＩＡのＵＳＢホストだと文字化けする。
- ＳｉＳならＯＫ。

<!-- dummy comment line for breaking list -->

えーと、ＶＩＡだとＵＨＣＩなので、７バイト受信トランザクションに４ｍＳ。
- ってことは１秒に１７５０バイト。
- ボーレートにすると１４０００ボー。

<!-- dummy comment line for breaking list -->
~
SIZE(24){バッターアウト！}

- ＶＩＡだめだめじゃん。
- っていうかＡＶＲｔｅｒｍ使うためにＨｉＳｐｅｅｄハブかＮＥＣのＵＳＢホスト買ってくる必要があるなんて・・・ナンセンスだよなー

<!-- dummy comment line for breaking list -->

- 送信パケットのペイロードは４バイトより増やせないけれど、受信パケットを１６とか３２にしておいて、ＡＶＲ側が可変長パケットで応答するというふうに変更しようかな・・・。面倒だけど。

<!-- dummy comment line for breaking list -->

- - - -
#### ＡＶＲｔｅｒｍは１９２００に追いついた。
- コントロール転送時の受信パケットを２４バイトに増やした。

		./checksize main.bin
		ROM: 1722 bytes (data=4)
		RAM: 109 bytes
- ３２バイトに増やすとたぶんスタックが足りない。
- ＡＶＲ＿ｔｅｒｍも改造。
- Ｈ８/３０４８Ｆのモニターと交信できた。
- 文字落ちしなくなった。

<!-- dummy comment line for breaking list -->

ついでにＷ３２＿ｔｅｒｍのほうも同じプロトコルに改造した。
- **Ｗ３２＿ｔｅｒｍを使用してＨ８/３０４８Ｆとの交信に初成功**

<!-- dummy comment line for breaking list -->
~
~
SIZE(32){おめでとう。俺}　これでＨ８はめでたくWindowsの仮想ＣＯＭ：ポートに接続完了だ。
~

- ちなみにＵＳＢホストはインテル（ＵＨＣＩ）でハイスピードハブなし直結だ。

<!-- dummy comment line for breaking list -->

**解説：**
- ＵＨＣＩは１回のコントロール転送（ベンダリクエスト＋８バイト受信）のトランザクションに４フレーム（＝４ｍＳ）を費やす。
- ＡＶＲ＿ｔｅｒｍではそのトランザクションで７バイトの受信データを転送するので都合１４０００ボーが転送スループットの最大である。
- Ｈ８/３０４８Ｆのモニターは１９２００ボーに設定されている。
- 間に合わない。

<!-- dummy comment line for breaking list -->

~
そこで、１トランザクションでの受信要求サイズを２４に増やした。
- １回のコントロール転送ではベンダリクエスト（８バイト）＋受信データ（可変長）最大２４バイトを受け取るように改良した。
- ２４バイトの転送が発生すると２フレーム増加し６ｍＳになるが転送量は２３文字に増えるため、３８００バイト/秒のスループットが稼げる。
- これはビットレートに換算すると３０４００ボーだ。
- これでも３８４００に達しないところが凧であるが・・・
- こうしておけば、ハイスピードハブを挟むだけでこの３倍くらいはいけるようになる（はずだ）

<!-- dummy comment line for breaking list -->

（マイクロフレームのおかげ・・・）
- ＡＶＲ側のメモリー的にはＲＳ２３２Ｃ受信バッファ（ＦＩＦＯ）が３２バイトとＵＳＢ転送バッファ（ＰＡＣＫＥＴバッファ）２４バイトでだいぶ圧迫される。
- これを１つにまとめられれば一挙にメモリー節約になるのだが・・・
- たぶんigorさんのはまとめているのだろう。
- なんとなく・・・チト無理か。

<!-- dummy comment line for breaking list -->

- - - -
#### usbdrvasm16.S解読
このソースは**芸術品**だ。
- クロック数のとおり寸分違わず時を刻むＣＰＵのなんと有難いことよ。
- 今どきのＣＰＵはキャッシュがあるのでタイミングなんて合うわけない。

<!-- dummy comment line for breaking list -->

~
- で、受信の同期取りはleapという８ビット変数だが。
- 初期値＝０
- １ビット読むたびに-3
- ８５回で-２５５（＝＝１）
- １バイトは８５.３３３３３cycles
- 最後に１引いて正（＋）だったら３足して１サイクルＮＯＰ。
- 「最後に」というのは１バイト受信後である。つまり１ビット単位でのleapはやってない。

<!-- dummy comment line for breaking list -->

さっぱり分からん。
- 単純化するならば、８５.３３３３という周期を生成したいなら、
- ｛８５，８５，８６｝（のくりかえし）というふうにすればよい。
- ほんとにバイト単位で３バイトに１回の１サイクル挿入をやっているのかどうか((正確にはビットスタッフを含めた８ビット時間ごとに１回分の挿入と２４ビット時間ごとに１回分の挿入が必要なはずだが、正味１バイトデータに対して１回の挿入になっているので誤差をどうやって処理しているのか解読出来なかった))
- 読解する力が足りない・・・

<!-- dummy comment line for breaking list -->

~
- 送信は00101010（０ｘ２Ａ）というビットパターンをbitcntに入れる。
- lsr bitcntするので、右から数えて、

		10, 11, 10, 11, 10, 11, というクロック進行になる。
- あとの２ビットはどうするかって？そりゃアンロールされたほうのルーチンで制御だ。(didStuff6,didStuff7)
- 送信についてはleapは使っていない。たぶん10.5cycle/bit固定なのだろう。
- 誤差が10.6666 vs 10.50000(?) = 0.16666 / 10.6666 と1.5％くらいあるが、ＵＳＢの許容範囲らしい。
- むしろ10,11,10,11のジッターのほうが気になる・・・。

		#
- 昔、磁気ドラムの回転（に同期するように）うまく利用して書かれた（大型？）計算機のプログラムがあったらしいが（ハッカーズディクショナリに書いてあった奴）、それに匹敵するくらいのトリックだ。

<!-- dummy comment line for breaking list -->
- - - -
#### メルの物語
磁気ドラムの話は、うろおぼえだったので、Google先生に聞いてきた。~
たぶんこれ。ちょっと極端かもしれない。
- [http://d.hatena.ne.jp/ystt/20070926](http://d.hatena.ne.jp/ystt/20070926) 

<!-- dummy comment line for breaking list -->

- - - -
#### usbdrvasm16.Sを読み返すと・・・
- やはり予想通り、受信時もEven bitとOdd bitで所要クロックを変えてある。
- クロック進行は10,11,10,11,10,11だ。
- これだと平均クロックが10.5000になり、１６ＭＨｚで必要な10.66666cycle/bitと比べて

<!-- dummy comment line for breaking list -->
１.５％程度速いコード進行になる。
- ８ビットで10.5×8＝８４クロックだ。
- しかし、正確な８ビットの時間は８５.３３３３３cycleなので、１バイト受信ごとに１クロック遅れるようにしてさらに３バイトに１回で１クロック遅れさせると８５.３３３３３cycle/byteを達成できる。
- １.５％の誤差は１バイト単位でスタートビットの同期合わせが出来るＲＳ２３２Ｃでは問題にならない((スタート、ストップビットまで合わせて１０ビットあるから１.５×１０＝１５％。パルス中央に対して最大１５％ずれてもなんとか許容できる))が、

<!-- dummy comment line for breaking list -->

- ＵＳＢの最大パケット長はペイロードだけでも８バイトあるので（ＰＬＬ的な処理でも入れない限りは）累積誤差((荒っぽく１６バイト時間＝１２８ビット時間を仮定すると１.５％×１２８＝１９２％もずれて別のビットを読んでしまう))でエラーを起こすことになる。

<!-- dummy comment line for breaking list -->

**このソースは「メルの物語」に匹敵するほどの価値があると思う。**

- - - -
目次



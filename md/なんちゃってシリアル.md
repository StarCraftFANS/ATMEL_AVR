***ＡＴｔｉｎｙ２３１３でＵＳＢｔｏシリアル変換器を作ろうと思う。 [#v05b6848]
- - - -
- プロトコルはいろいろ考えたが、コントロール転送（ベンダーリクエスト）のみを使うやり方で落ち着いた。
    - これだとエンドポイントを用意しなくて良いので、コードサイズ、ＳＲＡＭサイズを最小に出来る。
- ８バイトのコマンドパケットを送って、必要なら８バイトのリターンパケットを受け取る。
- コマンドパケットの内容（ベンダーリクエスト）

		   0      1      2      3      4      5      6      7
		+------+------+---------------------------+-------------+
		| req  | cmd  | 送信データ（最大４バイト）|   wlength   |
		+------+------+---------------------------+-------------+
    - reqはbmRequestTypeである。
    - wlengthは８固定（の予定）これはデバイスからホストへの受信パケットが後続する意味。
    - cmdは送信バイト数（０〜４）
    - cmdが５以上になった場合は、特殊コマンドとして解釈（ボーレート設定等）

<!-- dummy comment line for breaking list -->


~
- 受信パケット

		   0      1      2      3      4      5      6      7
		+------+------------------------------------------------+
		| size |     受信データ（最大７バイト）                 |
		+------+------------------------------------------------+
    - sizeは０〜７
    - sizeのＭＳＢが１になるときは送信が拒否された。(TxBuf FULL)
    - その場合ＰＣ側は同じデータを再送する。

<!-- dummy comment line for breaking list -->
~
- ターミナルソフト
    - AVR_Monitを改造して作る。
    - オプションで仮想エコーバックポートに対応したい。

<!-- dummy comment line for breaking list -->
~
- ファーム
    - ＲＳ２３２Ｃ受信はＵＳＡＲＴ割り込み駆動。
    - 送信はメインループ内のPoll()のループ内に仕掛ける（１ループで１文字）
    - ベンダーリクエストのパケットが来たら、送信バッファにとりあえず４文字をためておいて
    - ＵＳＡＲＴ受信したバッファをホストに送る。
    - 送信バッファが空になっていない場合は再送フラグを立てて、送信データを捨てる。

<!-- dummy comment line for breaking list -->

- - - -
- この一連のパケットのやり取りは普通のＵＨＣＩなら４フレーム(4mS)掛かる。
- ＳｉＳのＯＨＣＩ（ＥＨＣＩ）では１フレーム(1mS)でいける。
- 普通のＥＨＣＩ（ｉｎｔｅｌ含む）でも、間にＨｉＳｐｅｅｄハブを挟むことによって

<!-- dummy comment line for breaking list -->
だいたい１フレームで応答が帰ってくるようだ。

- - - -
**ということは**
- 送信スループットは最大４ｋＢ/秒（３２Ｋｂｐｓ相当）
- 受信スループットは最大７ｋＢ/秒（５６Ｋｂｐｓ相当）

<!-- dummy comment line for breaking list -->

- ハブを挟むとか、ＳｉＳのチップセットを使うとかの工夫をしない状態だと、この１／４。
- 送信は手入力のときなどは１回に１バイトになり、アップロードのときは４バイトまでいける。（と思う・・・）

<!-- dummy comment line for breaking list -->

- これで手を打とうではないか。
- かろうじてＭＩＤＩ速度だ。

<!-- dummy comment line for breaking list -->
~

- - - -
なぜＬｏｗＳｐｅｅｄのＢｕｌｋを使わない？
- ＶｉｓｔａやＬｉｎｕｘに対応できない。
- 残念だが、ＨｉＳｐｅｅｄハブに濾過される。
- 最高速のＳｉＳのＥＨＣＩでもバルクパケットの往復だと２フレーム掛かってしまう。
- だったら、１フレームで送受が完結するコントロール転送のほうがましだ。

<!-- dummy comment line for breaking list -->

- - - -
なぜＣＤＣクラスにしないのか？
- これもたぶんＨｉＳｐｅｅｄハブに濾過される。
- ＡＴｔｉｎｙ２３１３では逆立ちしても無理（コードサイズが２５６バイト以上オーバーする）

<!-- dummy comment line for breaking list -->

**なんちゃって方式**ではあるが、うまくいけば仮想ＣＯＭポートのエコーバックを利用してteratermからも使えるようになる（といいなぁ・・・）

~

#### ＬｏｗＳｐｅｅｄ　ＡＶＲＵＳＢの挙動に関するまとめ
- - - -
#### 転送モードの種類
どのみちＵＳＢにはこれだけしか転送モードは存在しない。
|転送モード|特徴|所要フレーム数|速度|
|コントロール転送|各種セットアップに使われるほか、ベンダー独自のコマンドも追加できる。|一回のトランザクションで１〜４フレーム程度（注１、２）|８ｋＢ／秒〜２ｋＢ／秒（注１、２）|
|インタラプト転送|一定期間おきに起こるような転送に使う|LowSpeedの規格では、１０フレームに１回よりも短く出来ないと定められている。実際それ以下には出来ない|１ｋＢ／秒以下|
|バルク転送|空いているＵＳＢ帯域を使ってフルに大量のデータを転送するのに向いている。（注３）|１フレームに１〜４パケット程度（注４）|８ｋＢ／秒〜３２ｋＢ／秒（注４）|
|アイソクロナス転送|主にＵＳＢオーディオなどでストリームデータを一定の帯域で送るのに使われる|LowSpeedでは非対応|LowSpeedでは非対応|

- ＵＳＢにおける１フレームとは１ｍＳのことで、ＵＳＢドライバーは１フレームを単位としてスケジューリングや同期処理を行っているようだ。このため、アプリケーションから同期（完了復帰型）read/writeを行なうと必ず１ｍＳの整数倍の時間だけ待たされる。

<!-- dummy comment line for breaking list -->

- ＵＳＢ２.０で定義された４８０Ｍｂｐｓモード（ＨｉｇｈＳｐｅｅｄ）においては、１フレームの１/８にあたる１２５μ秒を単位とするマイクロフレームが定義されたので、１ｍＳというレイテンシーをその１/８に短縮することが出来る。

<!-- dummy comment line for breaking list -->


~


- 注１）ｉｎｔｅｌを含む多くのホストコントローラで実測すると４フレーム掛かるので２ｋＢ／秒。
    - これはコントロール転送８バイトを送り、リザルト８バイトを受信した場合。

<!-- dummy comment line for breaking list -->

- 注２）ＳｉＳのコントローラを使用した場合、コントロール転送は１フレームで完結し、８ｋＢ／秒になる。
    - ＳｉＳコントローラを使用しない場合でも、ＨｉｇｈＳｐｅｅｄハブを挟めば、ほぼ８ｋＢ／秒の速度が出せるようだ。
    - これは、ホストから見てＬｏｗＳｐｅｅｄのデバイスがＨｉｇｈＳｐｅｅｄとみなされることで、トランザクションの時間単位が１ｍＳから１/８ｍＳに短縮される効果のようだ。

<!-- dummy comment line for breaking list -->

- 注３）**規格上、LowSpeedでのバルク転送はサポートされていない**

<!-- dummy comment line for breaking list -->

    - はずだが、ＷｉｎｄｏｗｓＸＰでは何故か使用できる。
    - Ｖｉｓｔａでははじかれる（たぶん）
    - ＨｉｇｈＳｐｅｅｄ（４８０Ｍｂｐｓ）ハブを挟んだ場合も濾過されて無視される（現在ハブのサンプル数が１個なので、まだ断言は出来ない）

<!-- dummy comment line for breaking list -->

- 注４）１フレーム（１ｍＳ）に４パケットを送るためにはusb_bulk_write()で一度に３２バイトのデータを渡す等の工夫が必要。そうでないときはusb_bulk_write()が常に１ｍＳ待つので結局１フレームに１パケット（８バイト）となる。

<!-- dummy comment line for breaking list -->


- - - -
#### 結論から言って、LowSpeedではどの転送モードが使えるのか？
- LowSpeedで正式にサポートされている転送モードはコントロール転送とインタラプト転送の２種類だけだ。
- インタラプト転送はポーリング間隔が１０ｍＳ単位になるので、とても遅くて使えない。

<!-- dummy comment line for breaking list -->

**結局LowSpeedにおいてはコントロール転送しか使いものにならないということだ**


**ＵＨＣＩは遅い**
- intel製のＵＳＢホストコントローラのこと。
- **遅い**の意味は、１回のコントロール転送（リザルト８バイト受信を入れて）に４フレーム（４ｍＳ）も掛かるという意味。
- １フレームで済ませてくれと言いたい。

<!-- dummy comment line for breaking list -->

**ＳｉＳのＯＨＣＩは速い**
- ＳｉＳ製のＵＳＢホストコントローラのこと。
- **速い**というのは語弊があるが、ほぼ理論上のレイテンシーで駆動できている。

<!-- dummy comment line for breaking list -->

**ＥＨＣＩで速くしたければＨｉＳｐｅｅｄハブを挟め**
- ＵＳＢ１.１までのホストコントローラは歴史的事情でインテル（ＵＨＣＩ）とそれ以外（ＯＨＣＩ）という風に実装が別々になってしまった。
- その反省を踏まえてＵＳＢ２.０のホストコントローラの設計（ハードウェアのインターフェース）はＥＨＣＩに統一された。
- つまり、現在ＵＳＢ２.０をサポートしているホストコントローラは全てＥＨＣＩ規格なはず。（パソコンに内蔵されるチップセットの話として）
    - 但し、ホストから見てFullSpeed,LowSpeedでの接続時はＵＨＣＩもしくはＯＨＣＩとしての動作になる。

<!-- dummy comment line for breaking list -->

参考
- [http://mcn.oops.jp/wiki/index.php?USB%2FHost%20Controller](http://mcn.oops.jp/wiki/index.php?USB%2FHost%20Controller) 

<!-- dummy comment line for breaking list -->

上記の資料によれば、ＶＩＡはＵＨＣＩに属するので、やっぱり遅いわけだ。


OHCI>NEC、SiS、Opti 等の Chip に使用されています。
- ということなので、不幸にもマザーボードがインテルとＶＩＡの人はＮＥＣのＵＳＢカードを買ってくればいいわけだ。
- SiSチップが乗っているＵＳＢカードって、見たこと無いなぁ・・・。
- Optiって、まだ生きてるの？

<!-- dummy comment line for breaking list -->

- - - -
#### LowSpeedバルク転送というのは裏技になってしまったが、どんなときに有効か？

- ＵＳＢ経由のＲＳ２３２Ｃシリアルデバイスを作る場合。例：

<!-- dummy comment line for breaking list -->
（[ＡＶＲ-ＣＤＣ](http://www.recursion.jp/avrcdc/indexj.html) ）
    - ＣＤＣ（通信デバイスクラス）のＲｘＤ、ＴｘＤストリームはＢｕｌｋタイプのエンドポイントで実装されているので、必然的にバルク転送を使うことになる。

<!-- dummy comment line for breaking list -->

- コントロール転送は常にエンドポイント０が使われるので、それとは独立したエンドポイントを用意したいとき。

<!-- dummy comment line for breaking list -->

- コントロール転送よりも速度（帯域）が欲しいとき。

<!-- dummy comment line for breaking list -->

**制限事項**
- ただし、上記の通りＷｉｎｄｏｗｓＸＰに限定される。
- デバイスとの間にＨｉｇｈＳｐｅｅｄハブを挟むことが出来ない。

<!-- dummy comment line for breaking list -->

- - - -
目次


